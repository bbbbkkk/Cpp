#include <iostream>
#include <string>
#include <vector>
using namespace std;
enum state
{
    EXIST,
    EMPTY,
    DELETE

};
template <typename k, typename v>
class hashdata
{
public:
    hashdata()
        : _state(EMPTY)
    {
    }

    hashdata(const pair<k, v> kv)
        : _kv(kv),
          _state(EXIST)
    {
    }

public:
    pair<k, v> _kv;
    state _state = EMPTY;
};

template <typename k>
struct defaulthashfunc
{
    size_t operator()(const k &key)
    {
        return (size_t)key;
    }
};
template <>
struct defaulthashfunc<string>
{
    size_t operator()(const string &str)
    {
        size_t hash = 0;
        for (auto ch : str)
        {
            hash *= 131;
            hash += ch;
        }
        return hash;
    }
};

template <typename k, typename v, typename Hashfunc = defaulthashfunc<k>>
class hashtable
{
public:
    hashtable()
        : _n(0)
    {
        _table.resize(10);
    }
    bool Insert(const pair<k, v> &kv)
    {
        if ((double)_n / (double)_table.size() > 0.7)
        {
            size_t newsize = _table.size() * 2;
            hashtable<k, v, Hashfunc> newht;
            newht._table.resize(newsize);
            for (size_t i = 0; i < _table.size(); i++)
            {
                if (_table[i]._state == EXIST)
                {
                    newht.Insert(_table[i]._kv);
                }
            }
            _table.swap(newht._table);
        }
        Hashfunc hf;
        size_t hashi = hf(kv.first) % _table.size();
        while (_table[hashi]._state == EXIST)
        {
            ++hashi;
            hashi %= _table.size();
        }
        _table[hashi]._kv = kv;
        _table[hashi]._state = EXIST;
        ++_n;
        return true;
    }
    hashdata<k, v> *Find(const k &key)
    {
        Hashfunc hf;
        size_t hashi = hf(key) % _table.size();
        while (_table[hashi]._state != EMPTY)
        {
            if (_table[hashi]._state == EXIST && _table[hashi]._kv.first == key)
            {
                return (hashdata<k, v> *)&_table[hashi];
            }
            ++hashi;
            hashi %= _table.size();
        }
        return nullptr;
    }
    bool erase(const k &key)
    {
        hashdata<k, v> *ret = Find(key);
        if (ret)
        {
            ret->_state = DELETE;
            --_n;
            return true;
        }
        return false;
    }
    void Print()
    {
        for (size_t i = 0; i < _table.size(); i++)
        {
            printf("[%d]", i);
            switch (_table[i]._state)
            {
            case EMPTY:
                cout << "EMPTY";
                break;
            case DELETE:
                cout << "DELETE";
                break;
            case EXIST:
                cout << "EXIST" << _table[i]._kv.first << ":" << _table[i]._kv.second;
                break;
            }
            cout << endl;
        }
    }

public:
    vector<hashdata<k, v>> _table;
    size_t _n;
};
void test1()
{
    hashtable<int, int, defaulthashfunc<int>> h1;
    h1.Insert(make_pair(1, 1));
    h1.Insert(make_pair(2, 2));
    h1.Insert(make_pair(4, 4));
    h1.Insert(make_pair(3, 3));
    h1.Insert(make_pair(13, 13));
    h1.Insert(make_pair(41, 41));
    // h1.erase(2);
    cout << "insert successful" << endl;
    h1.Print();
}

int main()
{
    test1();

    return 0;
}
