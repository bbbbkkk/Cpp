#include <iostream>
#include <string>
#include <vector>
using namespace std;
enum state
{
    EMPTY,
    EXIST,
    DELETE,
};
template <typename k, typename v>
class hashdata
{
public:
    // 默认构造-针对申请的空槽
    hashdata()
        : _state(EMPTY)
    {
    }
    // 带参构造-需要插入数据槽
    hashdata(const pair<k, v> &kv)
        : _kv(kv),
          _state(EXIST)
    {
    }

public:
    pair<k, v> _kv;
    state _state;
};
// 针对整形
template <typename k>
struct defaulthashfunc
{
    size_t operator()(const k &key)
    {
        return (size_t)key;
    }
};
// 模版特化-针对string类型
template <>
struct defaulthashfunc<string>
{
    size_t operator()(const string &str)
    {
        size_t hash = 0;
        for (auto e : str)
        {
            hash *= 131;
            hash += e;
        }
        return hash;
    }
};
template <typename k, typename v, typename defunc = defaulthashfunc<k>>
class hashtable
{
public:
    // 构造函数
    // 这里_table不用初始化，是因为前面resize(10)会调用10次默认构造函数
    hashtable()
        : _n(0)
    {
        _table.resize(10);
    }
    bool Insert(const pair<k, v> &kv)
    {
        // 检查扩容问题
        // 负载因子>0.7就需要扩容
        if ((double)_n / (double)_table.size() > 0.7)
        {
            size_t newSize = _table.size() * 2;
            hashtable<k, v, defunc> newht;
            newht._table.resize(newSize);
            for (size_t i = 0; i < _table.size(); i++)
            {
                if (_table[i]._state == EXIST)
                {
                    newht.Insert(_table[i]._kv);
                }
            }
            _table.swap(newht._table);
        }
        defaulthashfunc<k> df;
        size_t hashi = df(kv.first) % _table.size();
        while (_table[hashi]._state == EXIST)
        {
            hashi++;
            hashi %= _table.size();
        }
        // 找到位置并实现插入
        _table[hashi]._kv = kv;
        _table[hashi]._state = EXIST;
        _n++;
        return true;
    }
    hashdata<k, v> *Find(const k &key)
    {
        defunc hf;
        size_t hashi = hf(key) % _table.size();
        while (_table[hashi]._state != EMPTY)
        {
            if (_table[hashi]._state == EXIST && _table[hashi]._kv.first == key)
            {
                return (hashdata<k, v> *)&_table[hashi];
            }
        }
        return nullptr;
    }
    bool Erase(const k &key)
    {
        hashdata<k, v> *ret = Find(key);
        if (ret)
        {
            ret->_state = DELETE;
            _n--;
            return true;
        }
        return false;
    }
    void Print()
    {
        for (size_t i = 0; i < _table.size(); i++)
        {
            printf("[%zu]", i);
            switch (_table[i]._state)
            {
            case EMPTY:
                cout << "EMPTY";
                break;
            case DELETE:
                cout << "DELETE";
                break;
            case EXIST:
                cout << _table[i]._kv.first << ":" << _table[i]._kv.second;
            };
            cout << endl;
        }
        cout << "print successful\n";
    }

public:
    vector<hashdata<k, v>> _table;
    size_t _n;
};
void test1()
{
    hashtable<int, int, defaulthashfunc<int>> hat;
    hat.Insert(make_pair(3, 3));
    hat.Insert(make_pair(1, 1));
    hat.Insert(make_pair(9, 9));
    hat.Insert(make_pair(19, 19));
    hat.Insert(make_pair(2, 2));
    hat.Erase(1);
    hat.Print();
}
int main()
{
    test1();
    return 0;
}
