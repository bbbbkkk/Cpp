#include <iostream>
#include <string>
#include <vector>
using namespace std;
///////////////
// 开放定植法///
//////////////
enum state
{
    EMPTY,
    EXIST,
    DELETE,
};
template <typename k, typename v>
class hashdata
{
public:
    // 默认构造-针对申请的空槽
    hashdata()
        : _state(EMPTY)
    {
    }
    // 带参构造-需要插入数据槽
    hashdata(const pair<k, v> &kv)
        : _kv(kv),
          _state(EXIST)
    {
    }

public:
    pair<k, v> _kv;
    state _state;
};
// 针对整形
template <typename k>
struct defaulthashfunc
{
    size_t operator()(const k &key)
    {
        return (size_t)key;
    }
};
// 模版特化-针对string类型
template <>
struct defaulthashfunc<string>
{
    size_t operator()(const string &str)
    {
        size_t hash = 0;
        for (auto e : str)
        {
            hash *= 131;
            hash += e;
        }
        return hash;
    }
};
template <typename k, typename v, typename defunc = defaulthashfunc<k>>
class hashtable
{
public:
    // 构造函数
    // 这里_table不用初始化，是因为前面resize(10)会调用10次默认构造函数
    hashtable()
        : _n(0)
    {
        _table.resize(10);
    }
    bool Insert(const pair<k, v> &kv)
    {
        // 检查扩容问题
        // 负载因子>0.7就需要扩容
        if ((double)_n / (double)_table.size() > 0.7)
        {
            size_t newSize = _table.size() * 2;
            hashtable<k, v, defunc> newht;
            newht._table.resize(newSize);
            for (size_t i = 0; i < _table.size(); i++)
            {
                if (_table[i]._state == EXIST)
                {
                    newht.Insert(_table[i]._kv);
                }
            }
            _table.swap(newht._table);
        }
        defaulthashfunc<k> df;
        size_t hashi = df(kv.first) % _table.size();
        while (_table[hashi]._state == EXIST)
        {
            hashi++;
            hashi %= _table.size();
        }
        // 找到位置并实现插入
        _table[hashi]._kv = kv;
        _table[hashi]._state = EXIST;
        _n++;
        return true;
    }
    hashdata<k, v> *Find(const k &key)
    {
        defunc hf;
        size_t hashi = hf(key) % _table.size();
        while (_table[hashi]._state != EMPTY)
        {
            if (_table[hashi]._state == EXIST && _table[hashi]._kv.first == key)
            {
                return (hashdata<k, v> *)&_table[hashi];
            }
        }
        return nullptr;
    }
    bool Erase(const k &key)
    {
        hashdata<k, v> *ret = Find(key);
        if (ret)
        {
            ret->_state = DELETE;
            _n--;
            return true;
        }
        return false;
    }
    void Print()
    {
        for (size_t i = 0; i < _table.size(); i++)
        {
            printf("[%zu]", i);
            switch (_table[i]._state)
            {
            case EMPTY:
                cout << "EMPTY";
                break;
            case DELETE:
                cout << "DELETE";
                break;
            case EXIST:
                cout << _table[i]._kv.first << ":" << _table[i]._kv.second;
            };
            cout << endl;
        }
        cout << "print successful\n";
    }

public:
    vector<hashdata<k, v>> _table;
    size_t _n;
};
/////////////
// 哈希桶////
////////////

namespace hashi_bucket
{
    template <typename k, typename v>
    struct hashinode
    {
        pair<k, v> _kv;
        hashinode<k, v> *_next;
        // 构造函数
        hashinode(const pair<k, v> &kv)
            : _kv(kv),
              _next(nullptr) {};
    };

    template <typename k, typename v, typename defunc = defaulthashfunc<k>>
    class hashtable
    {
        typedef hashinode<k, v> node;

    public:
        hashtable()
            : _n(0)
        {
            _table.resize(10, nullptr);
        }
        ~hashtable()
        {
            for (size_t i = 0; i < _table.size(); i++)
            {
                node *cur = _table[i];
                while (cur)
                {
                    node *next = cur->_next;
                    delete cur;
                    cur = next;
                }
                _table[i] = nullptr;
            }
        }
        bool Insert(const pair<k, v> &kv)
        {
            // 找到就说重复，无法插入，因为这里实现的是set或map
            if (Find(kv.first))
            {
                return false;
            }
            // 扩容问题
            if (_n == _table.size())
            {
                size_t newsize = _table.size() * 2;
                vector<node *> newtable;
                defaulthashfunc<k> df;
                newtable.resize(newsize, nullptr);
                for (size_t i = 0; i < _table.size(); i++)
                {
                    node *cur = _table[i];
                    while (cur)
                    {
                        node *next = cur->_next;
                        // 重新在新的newtable中分配
                        size_t hashi = df(cur->_kv.first) % newsize;
                        cur->_next = newtable[hashi];
                        newtable[hashi] = cur;
                        cur = next;
                    }
                    // 将旧的table给清空
                    _table[i] = nullptr;
                }
                _table.swap(newtable);
            }
            // 插入
            defaulthashfunc<k> df;
            size_t hashi = df(kv.first) % _table.size();
            node *newnode = new node(kv);
            newnode->_next = _table[hashi];
            _table[hashi] = newnode;
            ++_n;
            return true;
        }
        hashinode<k, v> *Find(const k &key)
        {
            defunc hf;
            size_t hashi = hf(key) % _table.size();
            node *cur = _table[hashi];
            while (cur)
            {
                if (cur->_kv.first == key)
                {
                    return cur;
                }
                cur = cur->_next;
            }
            return nullptr;
        }
        bool erase(const k &key)
        {
            defunc hf;
            size_t hashi = hf(key) % _table.size();
            hashinode<k, v> *ret = Find(key);
            node *prev = nullptr;
            node *cur = _table[hashi];
            while (cur)
            {
                if (cur->_kv.first == key)
                {
                    if (prev == nullptr)
                    {
                        _table[hashi] = cur->_next;
                    }
                    else
                    {
                        prev->_next = cur->_next;
                        delete cur;
                    }
                    return true;
                }
                prev = cur;
                cur = cur->_next;
            }
            return false;
        }

        void Print()
        {
            for (size_t i = 0; i < _table.size(); i++)
            {
                printf("[%d]->", i);
                node *cur = _table[i];
                while (cur)
                {
                    cout << cur->_kv.first << ":" << cur->_kv.second << "->";
                    cur = cur->_next;
                }
                printf("NULL\n");
            }
            cout << endl;
        }

    public:
        vector<node *> _table;
        size_t _n;
    };
};
void test1()
{
    hashtable<int, int, defaulthashfunc<int>> hat;
    hat.Insert(make_pair(3, 3));
    hat.Insert(make_pair(1, 1));
    hat.Insert(make_pair(9, 9));
    hat.Insert(make_pair(19, 19));
    hat.Insert(make_pair(2, 2));
    hat.Erase(1);
    hat.Print();
}
void test2()
{
    hashi_bucket::hashtable<int, int, defaulthashfunc<int>> h2;
    h2.Insert(make_pair(1, 1));
    h2.Insert(make_pair(10, 10));
    h2.Insert(make_pair(7, 7));
    h2.Insert(make_pair(4, 4));
    h2.Insert(make_pair(14, 14));
    h2.Insert(make_pair(5, 5));
    h2.Print();
}
int main()
{
    // test1();
    test2();
    return 0;
}
